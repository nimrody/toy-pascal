package main

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

// Opcodes - These must match the VM's opcodes exactly.
const (
	OpPushConst   byte = 0x01
	OpPop         byte = 0x02
	OpAdd         byte = 0x10
	OpSub         byte = 0x11
	OpMul         byte = 0x12
	OpDiv         byte = 0x13
	OpCmpEq       byte = 0x14
	OpCmpNeq      byte = 0x15
	OpCmpLt       byte = 0x16
	OpCmpGt       byte = 0x17
	OpCmpLe       byte = 0x18
	OpCmpGe       byte = 0x19
	OpLoadGlobal  byte = 0x20
	OpStoreGlobal byte = 0x21
	OpLoadLocal   byte = 0x22
	OpStoreLocal  byte = 0x23
	OpJump        byte = 0x30
	OpJumpIfFalse byte = 0x31
	OpCall        byte = 0x40
	OpRet         byte = 0x41
	OpNew         byte = 0x50
	OpLoadIndirect  byte = 0x51
	OpStoreIndirect byte = 0x52
	OpHalt        byte = 0xFF
)

// MnemonicToOpcode maps the string representation of an instruction to its opcode.
var MnemonicToOpcode = map[string]byte{
	"PUSH_CONST":    OpPushConst,
	"POP":           OpPop,
	"ADD":           OpAdd,
	"SUB":           OpSub,
	"MUL":           OpMul,
	"DIV":           OpDiv,
	"CMP_EQ":        OpCmpEq,
	"CMP_NEQ":       OpCmpNeq,
	"CMP_LT":        OpCmpLt,
	"CMP_GT":        OpCmpGt,
	"CMP_LE":        OpCmpLe,
	"CMP_GE":        OpCmpGe,
	"LOAD_GLOBAL":   OpLoadGlobal,
	"STORE_GLOBAL":  OpStoreGlobal,
	"LOAD_LOCAL":    OpLoadLocal,
	"STORE_LOCAL":   OpStoreLocal,
	"JUMP":          OpJump,
	"JUMP_IF_FALSE": OpJumpIfFalse,
	"CALL":          OpCall,
	"RET":           OpRet,
	"NEW":           OpNew,
	"LOAD_INDIRECT": OpLoadIndirect,
	"STORE_INDIRECT":OpStoreIndirect,
	"HALT":          OpHalt,
}

// intToBytes converts an int32 to its 4-byte little-endian representation.
func intToBytes(n int32) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(n))
	return b
}

// Assemble reads an assembly file and converts it to bytecode.
func Assemble(inputFile, outputFile string) error {
	file, err := os.Open(inputFile)
	if err != nil {
		return fmt.Errorf("could not open input file: %w", err)
	}
	defer file.Close()

	var bytecode []byte
	scanner := bufio.NewScanner(file)
	lineNumber := 0

	for scanner.Scan() {
		lineNumber++
		line := scanner.Text()

		// Find the comment character '#' and slice the string to remove the comment.
		if commentIndex := strings.Index(line, "#"); commentIndex != -1 {
			line = line[:commentIndex]
		}

		// Trim whitespace from the potentially comment-stripped line.
		line = strings.TrimSpace(line)

		// Ignore empty lines (which includes lines that only contained a comment).
		if line == "" {
			continue
		}

		// Split line into mnemonic and arguments
		parts := strings.Fields(line)
		mnemonic := strings.ToUpper(parts[0])

		opcode, exists := MnemonicToOpcode[mnemonic]
		if !exists {
			return fmt.Errorf("line %d: unknown mnemonic '%s'", lineNumber, mnemonic)
		}

		bytecode = append(bytecode, opcode)

		// Handle arguments based on the instruction
		switch opcode {
		case OpPushConst, OpLoadGlobal, OpStoreGlobal, OpLoadLocal, OpStoreLocal, OpJump, OpJumpIfFalse, OpNew:
			if len(parts) != 2 {
				return fmt.Errorf("line %d: mnemonic %s expects 1 argument, got %d", lineNumber, mnemonic, len(parts)-1)
			}
			arg, err := strconv.ParseInt(parts[1], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid argument for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, intToBytes(int32(arg))...)

		case OpCall:
			if len(parts) != 3 {
				return fmt.Errorf("line %d: mnemonic %s expects 2 arguments, got %d", lineNumber, mnemonic, len(parts)-1)
			}
			// First argument: address or built-in ID
			addr, err := strconv.ParseInt(parts[1], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid address/ID for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, intToBytes(int32(addr))...)

			// Second argument: number of arguments
			numArgs, err := strconv.ParseInt(parts[2], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid numArgs for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, intToBytes(int32(numArgs))...)
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading input file: %w", err)
	}

	// Write the generated bytecode to the output file
	err = ioutil.WriteFile(outputFile, bytecode, 0644)
	if err != nil {
		return fmt.Errorf("could not write to output file: %w", err)
	}

	return nil
}

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: go run assembler.go <input_file.asm> <output_file.bin>")
		os.Exit(1)
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]

	// Create a sample assembly file for testing if it doesn't exist
	if _, err := os.Stat("program.asm"); os.IsNotExist(err) {
		sampleAsm := `# Sample program for the Toy Pascal VM
# Equivalent pseudo-code:
# var x: Integer; // global at address 0
# x = (100 + 20) * 2 - 50; // result should be 190
# print(x);
# print(42);

# Expression: (100 + 20) * 2 - 50
PUSH_CONST 100
PUSH_CONST 20
ADD

PUSH_CONST 2
MUL

PUSH_CONST 50
SUB

# Store result in global 0
STORE_GLOBAL 0

# Load from global and print
LOAD_GLOBAL 0
CALL -1 1  # Call built-in print

# Print a constant directly
PUSH_CONST 42
CALL -1 1  # Call built-in print

HALT
`
		ioutil.WriteFile("program.asm", []byte(sampleAsm), 0644)
		fmt.Println("Created sample file: program.asm")
	}

	fmt.Printf("Assembling %s -> %s\n", inputFile, outputFile)
	err := Assemble(inputFile, outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Assembly successful.")
}
