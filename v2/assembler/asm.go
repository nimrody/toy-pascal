package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"nimrody.com/toypascal/v2/assembler/isa"
)

// Assemble reads an assembly file and converts it to bytecode.
func Assemble(inputFile, outputFile string) error {
	file, err := os.Open(inputFile)
	if err != nil {
		return fmt.Errorf("could not open input file: %w", err)
	}
	defer file.Close()

	var bytecode []byte
	scanner := bufio.NewScanner(file)
	lineNumber := 0

	for scanner.Scan() {
		lineNumber++
		line := scanner.Text()

		// Find the comment character '#' and slice the string to remove the comment.
		if commentIndex := strings.Index(line, "#"); commentIndex != -1 {
			line = line[:commentIndex]
		}

		// Trim whitespace from the potentially comment-stripped line.
		line = strings.TrimSpace(line)

		// Ignore empty lines (which includes lines that only contained a comment).
		if line == "" {
			continue
		}

		// Split line into mnemonic and arguments
		parts := strings.Fields(line)
		mnemonic := strings.ToUpper(parts[0])

		opcode, exists := isa.MnemonicToOpcode[mnemonic]
		if !exists {
			return fmt.Errorf("line %d: unknown mnemonic '%s'", lineNumber, mnemonic)
		}

		bytecode = append(bytecode, opcode)

		// Handle arguments based on the instruction
		switch opcode {
		case isa.OpPushConst, isa.OpLoadGlobal, isa.OpStoreGlobal, isa.OpLoadLocal, isa.OpStoreLocal, isa.OpJump, isa.OpJumpIfFalse, isa.OpNew:
			if len(parts) != 2 {
				return fmt.Errorf("line %d: mnemonic %s expects 1 argument, got %d", lineNumber, mnemonic, len(parts)-1)
			}
			arg, err := strconv.ParseInt(parts[1], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid argument for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, isa.IntToBytes(int32(arg))...)

		case isa.OpCall:
			if len(parts) != 3 {
				return fmt.Errorf("line %d: mnemonic %s expects 2 arguments, got %d", lineNumber, mnemonic, len(parts)-1)
			}
			// First argument: address or built-in ID
			addr, err := strconv.ParseInt(parts[1], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid address/ID for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, isa.IntToBytes(int32(addr))...)

			// Second argument: number of arguments
			numArgs, err := strconv.ParseInt(parts[2], 10, 32)
			if err != nil {
				return fmt.Errorf("line %d: invalid numArgs for %s: %w", lineNumber, mnemonic, err)
			}
			bytecode = append(bytecode, isa.IntToBytes(int32(numArgs))...)
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading input file: %w", err)
	}

	// Write the generated bytecode to the output file
	err = ioutil.WriteFile(outputFile, bytecode, 0644)
	if err != nil {
		return fmt.Errorf("could not write to output file: %w", err)
	}

	return nil
}

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: go run assembler.go <input_file.asm> <output_file.bin>")
		os.Exit(1)
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]

	// Create a sample assembly file for testing if it doesn't exist
	if _, err := os.Stat("program.asm"); os.IsNotExist(err) {
		sampleAsm := `# Sample program for the Toy Pascal VM
# Equivalent pseudo-code:
# var x: Integer; // global at address 0
# x = (100 + 20) * 2 - 50; // result should be 190
# print(x);
# print(42);

# Expression: (100 + 20) * 2 - 50
PUSH_CONST 100
PUSH_CONST 20
ADD

PUSH_CONST 2
MUL

PUSH_CONST 50
SUB

# Store result in global 0
STORE_GLOBAL 0

# Load from global and print
LOAD_GLOBAL 0
CALL -1 1  # Call built-in print

# Print a constant directly
PUSH_CONST 42
CALL -1 1  # Call built-in print

HALT
`
		ioutil.WriteFile("program.asm", []byte(sampleAsm), 0644)
		fmt.Println("Created sample file: program.asm")
	}

	fmt.Printf("Assembling %s -> %s\n", inputFile, outputFile)
	err := Assemble(inputFile, outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Assembly successful.")
}
